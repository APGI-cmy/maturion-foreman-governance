name: Governance Layer-Down Dispatch

# TERMINOLOGY (per ECOSYSTEM_VOCABULARY.md v1.1.0 and LAYERING_AND_RIPPLING_AUTOMATION_STRATEGY.md v1.0.0):
# - LAYERING DOWN: Cross-repo distribution of governance artifacts (this workflow).
# - RIPPLING: Within-repo integration/synchronization — occurs inside consumer repos AFTER layer-down.
# These are distinct, sequential processes with different automation boundaries.
# See: governance/strategy/LAYERING_AND_RIPPLING_AUTOMATION_STRATEGY.md
#
# TWO-SIGNAL DISPATCH (per LAYER_DOWN_INVESTIGATION_REPORT_20260227.md):
# For each enabled consumer repo this workflow sends two signals on every canonical push to main:
#   Signal 1 — GitHub Issue: human-readable instructions auto-assigned to the governance-liaison.
#   Signal 2 — repository_dispatch (governance_ripple): machine event that triggers
#              governance-ripple-sync.yml inside the consumer repo for automated
#              CANON_INVENTORY drift detection and alignment PR creation.
# Without Signal 2, governance-ripple-sync.yml never fires automatically regardless of
# how many issues are created. Both signals are required for a complete layer-down.
#
# MANUAL BACKFILL (workflow_dispatch):
# Governance agents and operators may trigger this workflow manually via the GitHub Actions UI
# or API to recover from missed layer-down events. Provide a mandatory 'reason' describing the
# backfill context and an optional 'commit_sha' to reference the historical commit being backfilled.
# Manual dispatch sends both signals to all enabled consumer repos regardless of which files changed.
# See governance/runbooks/LAYER_DOWN_AUDIT_AND_BACKFILL_RUNBOOK.md for the full procedure.

on:
  push:
    branches:
      - main
    paths:
      - 'governance/canon/**'
      - 'governance/schemas/**'
      - 'governance/templates/**'
      - 'governance/executable/workflows/**'
      - 'BUILD_PHILOSOPHY.md'
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual dispatch (e.g. backfill for missed layer-down event)'
        required: true
        type: string
      commit_sha:
        description: 'Commit SHA to reference in the layer-down issue (defaults to HEAD when not provided)'
        required: false
        type: string

permissions:
  contents: read

jobs:
  dispatch-layer-down:
    name: Create Layer-Down Issues in Consumer Repos
    runs-on: ubuntu-latest

    steps:
      - name: Checkout governance repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changed governance artifacts
        id: changes
        run: |
          # For workflow_dispatch (manual backfill), skip git diff — all enabled consumers
          # will receive the dispatch signal regardless of which files changed.
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "changed_files<<EOF" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "agent_files_changed=false" >> $GITHUB_OUTPUT
            echo "Manual dispatch triggered. Reason: ${{ inputs.reason }}"
            echo "All enabled consumer repos will receive the layer-down signal."
            exit 0
          fi

          # List files changed in this push
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git show --name-only --pretty=format: HEAD)

          # Detect PUBLIC_API canon / schema / template / executable-workflow changes (layer-down triggers)
          LAYERDOWN_FILES=$(echo "$CHANGED_FILES" | grep -E '^governance/(canon|schemas|templates|executable/workflows)/' || true)
          echo "changed_files<<EOF" >> $GITHUB_OUTPUT
          echo "$LAYERDOWN_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Agent file detection gate:
          # If any .github/agents/*.md files are in the changed set, the consumer ripple PR
          # MUST be created as DRAFT and escalated to CS2 for approval.
          AGENT_FILES=$(echo "$CHANGED_FILES" | grep -E '\.github/agents/.*\.md$' || true)
          if [ -n "$AGENT_FILES" ]; then
            echo "agent_files_changed=true" >> $GITHUB_OUTPUT
          else
            echo "agent_files_changed=false" >> $GITHUB_OUTPUT
          fi

          echo "Changed governance artifacts:"
          echo "$LAYERDOWN_FILES"
          echo "Agent files changed: $([ -n "$AGENT_FILES" ] && echo 'YES - CS2 escalation required' || echo 'NO')"

      - name: Read consumer registry
        id: registry
        run: |
          if [ ! -f "governance/CONSUMER_REPO_REGISTRY.json" ]; then
            echo "FATAL: Consumer registry not found"
            exit 1
          fi

          # Extract enabled consumer repos and their governance liaisons (tab-separated)
          CONSUMERS=$(jq -r '.consumers[] | select(.enabled == true) | [.repository, (.governance_liaison // "")] | @tsv' governance/CONSUMER_REPO_REGISTRY.json)
          echo "consumers<<EOF" >> $GITHUB_OUTPUT
          echo "$CONSUMERS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "Will create layer-down issues in:"
          echo "$CONSUMERS" | awk -F'\t' '{print "  " $1 " (liaison: " ($2 != "" ? $2 : "unassigned") ")"}'

      - name: Validate consumer liaison configuration
        # Fail fast if any enabled consumer has no governance_liaison configured.
        # An empty liaison means layer-down issues arrive unassigned — a silent non-compliance risk.
        # Fix: populate governance_liaison in CONSUMER_REPO_REGISTRY.json for all enabled consumers.
        run: |
          EMPTY_LIAISONS=$(jq -r '.consumers[] | select(.enabled == true) | select((.governance_liaison // "") == "") | .repository' governance/CONSUMER_REPO_REGISTRY.json)
          if [ -n "$EMPTY_LIAISONS" ]; then
            echo "ERROR: The following enabled consumer repos have empty governance_liaison fields:"
            echo "$EMPTY_LIAISONS"
            echo "Layer-down dispatch blocked. Populate governance_liaison in CONSUMER_REPO_REGISTRY.json before proceeding."
            exit 1
          fi
          echo "All enabled consumer repos have governance_liaison configured."

      - name: Create layer-down issues in consumer repos
        env:
          GH_TOKEN: ${{ secrets.MATURION_BOT_TOKEN }}
        run: |
          # For workflow_dispatch, use the provided commit_sha input (if given) or HEAD.
          # For push events, always use github.sha (the push commit).
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.commit_sha }}" ]; then
            COMMIT_SHA="${{ inputs.commit_sha }}"
          else
            COMMIT_SHA="${{ github.sha }}"
          fi
          COMMIT_MESSAGE="${{ github.event.head_commit.message }}"
          # For manual dispatch, use the reason as the commit message context
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            COMMIT_MESSAGE="[Manual backfill] ${{ inputs.reason }}"
          fi
          TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          DATE="$(date -u +%Y-%m-%d)"
          SHORT_SHA="${COMMIT_SHA:0:8}"
          AGENT_FILES_CHANGED="${{ steps.changes.outputs.agent_files_changed }}"
          CHANGED_FILES="${{ steps.changes.outputs.changed_files }}"

          # Build changed-files markdown list
          FILES_LIST=""
          while IFS= read -r f; do
            [ -z "$f" ] && continue
            FILES_LIST="${FILES_LIST}"$'- `'"${f}"$'`\n'
          done <<< "$CHANGED_FILES"
          if [ -z "$FILES_LIST" ]; then
            FILES_LIST="_No PUBLIC_API governance files changed in this push._"
          fi

          # Agent file detection section (appended to issue body when agent files changed)
          AGENT_SECTION=""
          if [ "$AGENT_FILES_CHANGED" = "true" ]; then
            AGENT_SECTION="$(printf '## Agent File Detection Gate - CS2 Approval Required\n\nOne or more agent contract files changed in this governance push.\n\n**Per LAYERING_AND_RIPPLING_AUTOMATION_STRATEGY.md Section 4.3 and 8.2:**\n- The consumer repo ripple PR **MUST be created as DRAFT**.\n- The governance-liaison **MUST create an escalation document** at:\n  `.agent-workspace/<agent>/escalation-inbox/agent-contract-ripple-escalation-<date>.md`\n- **Only CS2 (Johan Ras) may approve and merge** the ripple PR.\n- Auto-merge is **NOT permitted** for agent file changes.\n\n**Authority**: CS2_AGENT_FILE_AUTHORITY_MODEL.md | AGENT_CONTRACT_PROTECTION_PROTOCOL.md')"
          fi

          # Build issue body from template, substituting variables
          ISSUE_TEMPLATE=".github/layer-down-issue-template.md"
          if [ ! -f "$ISSUE_TEMPLATE" ]; then
            echo "FATAL: Issue template not found at $ISSUE_TEMPLATE"
            exit 1
          fi

          # Build and post issue for each enabled consumer
          echo "${{ steps.registry.outputs.consumers }}" | while IFS=$'\t' read -r repo liaison; do
            [ -z "$repo" ] && continue

            if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
              ISSUE_TITLE="[Layer-Down][Backfill] Governance Changes - ${DATE} (${SHORT_SHA})"
            else
              ISSUE_TITLE="[Layer-Down] Propagate Governance Changes - ${DATE} (${SHORT_SHA})"
            fi

            # Substitute template variables
            ISSUE_BODY=$(sed \
              -e "s|{{COMMIT_SHA}}|${COMMIT_SHA}|g" \
              -e "s|{{SHORT_SHA}}|${SHORT_SHA}|g" \
              -e "s|{{TIMESTAMP}}|${TIMESTAMP}|g" \
              -e "s|{{COMMIT_MESSAGE}}|${COMMIT_MESSAGE}|g" \
              -e "s|{{FILES_LIST}}|${FILES_LIST}|g" \
              -e "s|{{AGENT_SECTION}}|${AGENT_SECTION}|g" \
              "$ISSUE_TEMPLATE")

            echo "Creating layer-down issue in $repo..."

            CREATE_ARGS=(
              -f "title=$ISSUE_TITLE"
              -f "body=$ISSUE_BODY"
              -f "labels[]=governance"
              -f "labels[]=layer-down"
              -f "labels[]=high-priority"
            )

            # Assign to governance-liaison if configured for this repo
            if [ -n "$liaison" ]; then
              CREATE_ARGS+=(-f "assignees[]=$liaison")
            fi

            gh api repos/$repo/issues \
              -X POST \
              -H "Accept: application/vnd.github+json" \
              "${CREATE_ARGS[@]}" \
              && echo "  Issue created in $repo" \
              || echo "  Issue creation failed for $repo (labels/assignees may not exist yet)"
          done

      - name: Dispatch governance_ripple repository_dispatch to consumer repos
        # Signal 2: machine event that triggers governance-ripple-sync.yml in each consumer repo.
        # Without this signal, governance-ripple-sync.yml (which listens on
        # repository_dispatch: types: [governance_ripple]) never fires automatically.
        # Non-blocking: a failure here logs a warning but does not prevent issue creation (Signal 1).
        env:
          GH_TOKEN: ${{ secrets.MATURION_BOT_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.commit_sha }}" ]; then
            COMMIT_SHA="${{ inputs.commit_sha }}"
          else
            COMMIT_SHA="${{ github.sha }}"
          fi
          SHORT_SHA="${COMMIT_SHA:0:8}"
          TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          AGENT_FILES_CHANGED="${{ steps.changes.outputs.agent_files_changed }}"

          echo "${{ steps.registry.outputs.consumers }}" | while IFS=$'\t' read -r repo liaison; do
            [ -z "$repo" ] && continue
            echo "Dispatching governance_ripple to $repo..."
            gh api "repos/$repo/dispatches" \
              -X POST \
              -H "Accept: application/vnd.github+json" \
              -f "event_type=governance_ripple" \
              -f "client_payload[source_repo]=${{ github.repository }}" \
              -f "client_payload[commit_sha]=${COMMIT_SHA}" \
              -f "client_payload[short_sha]=${SHORT_SHA}" \
              -f "client_payload[timestamp]=${TIMESTAMP}" \
              -f "client_payload[agent_files_changed]=${AGENT_FILES_CHANGED}" \
              && echo "  governance_ripple dispatched to $repo" \
              || echo "  repository_dispatch failed for $repo (MATURION_BOT_TOKEN may lack contents:write scope in that repo)"
          done

      - name: Record layer-down dispatch
        run: |
          mkdir -p .agent-admin/ripple
          TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          DATESTAMP="$(date +%Y%m%d-%H%M%S)"
          RECORD_FILE=".agent-admin/ripple/layer-down-dispatch-${DATESTAMP}.json"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.commit_sha }}" ]; then
            EFFECTIVE_SHA="${{ inputs.commit_sha }}"
          else
            EFFECTIVE_SHA="${{ github.sha }}"
          fi
          DISPATCH_TYPE="${{ github.event_name }}"
          printf '{\n  "schema_version": "1.0.0",\n  "type": "layer_down_dispatch",\n  "dispatch_type": "%s",\n  "timestamp": "%s",\n  "commit_sha": "%s",\n  "agent_files_changed": %s,\n  "consumers_notified": %s\n}\n' \
            "$DISPATCH_TYPE" \
            "$TIMESTAMP" \
            "$EFFECTIVE_SHA" \
            "${{ steps.changes.outputs.agent_files_changed }}" \
            "$(jq -c '[.consumers[] | select(.enabled == true) | .repository]' governance/CONSUMER_REPO_REGISTRY.json)" \
            > "$RECORD_FILE"
          echo "Layer-down dispatch recorded at ${RECORD_FILE}"
