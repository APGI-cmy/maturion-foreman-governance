name: Merge Gate Interface

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, unlabeled]

permissions:
  contents: read
  pull-requests: read

jobs:
  # Job 1: Merge Gate Verdict
  # Validates required evidence artifacts exist and validates schemas
  merge-gate-verdict:
    name: merge-gate/verdict
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Classify PR type
        id: classify
        run: |
          # Deterministic PR classification per MERGE_GATE_INTERFACE_STANDARD.md
          
          # Get changed files
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD || echo "")
          
          # Check for label overrides
          if [[ "${{ contains(github.event.pull_request.labels.*.name, 'governance-only') }}" == "true" ]]; then
            echo "pr_type=governance" >> $GITHUB_OUTPUT
            echo "‚úÖ PR classified as: governance (label override)"
            exit 0
          fi
          
          if [[ "${{ contains(github.event.pull_request.labels.*.name, 'docs-only') }}" == "true" ]]; then
            echo "pr_type=docs" >> $GITHUB_OUTPUT
            echo "‚úÖ PR classified as: docs (label override)"
            exit 0
          fi
          
          # Check for governance changes
          if echo "$CHANGED_FILES" | grep -qE '^(governance/|\.agent$|\.agent-admin/)'; then
            echo "pr_type=governance" >> $GITHUB_OUTPUT
            echo "‚úÖ PR classified as: governance"
            exit 0
          fi
          
          # Check for docs-only
          if echo "$CHANGED_FILES" | grep -qvE '\.(md|txt|rst)$' && echo "$CHANGED_FILES" | grep -qvE '^docs/'; then
            echo "pr_type=code" >> $GITHUB_OUTPUT
            echo "‚úÖ PR classified as: code"
          else
            echo "pr_type=docs" >> $GITHUB_OUTPUT
            echo "‚úÖ PR classified as: docs"
          fi

      - name: Validate evidence artifacts
        run: |
          echo "=== Validating Evidence Artifacts ==="
          
          # Check for required evidence bundle per EVIDENCE_ARTIFACT_BUNDLE_STANDARD.md
          MISSING_ARTIFACTS=()
          
          # 1. Check for prehandover proof
          if [ ! -f ".agent-admin/prehandover/prehandover_proof.md" ]; then
            if ls .agent-admin/prehandover/prehandover_proof_*.md 1> /dev/null 2>&1; then
              echo "‚úÖ Prehandover proof found (PR-specific)"
            else
              MISSING_ARTIFACTS+=("prehandover_proof")
              echo "‚ùå Missing: .agent-admin/prehandover/prehandover_proof*.md"
            fi
          else
            echo "‚úÖ Prehandover proof found"
          fi
          
          # 2. Check for gate results (if code changes)
          if [ "${{ steps.classify.outputs.pr_type }}" = "code" ]; then
            if [ ! -f ".agent-admin/gates/gate_results.json" ]; then
              if ls .agent-admin/gates/gate_results_*.json 1> /dev/null 2>&1; then
                echo "‚úÖ Gate results found (PR-specific)"
              else
                MISSING_ARTIFACTS+=("gate_results")
                echo "‚ùå Missing: .agent-admin/gates/gate_results*.json"
              fi
            else
              echo "‚úÖ Gate results found"
            fi
          fi
          
          # Report missing artifacts
          if [ ${#MISSING_ARTIFACTS[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå EVIDENCE VALIDATION FAILED"
            echo ""
            echo "Missing required artifacts:"
            for artifact in "${MISSING_ARTIFACTS[@]}"; do
              echo "  - $artifact"
            done
            echo ""
            echo "Required by: EVIDENCE_ARTIFACT_BUNDLE_STANDARD.md"
            echo "Action: Create missing artifacts in .agent-admin/<category>/"
            exit 1
          fi
          
          echo ""
          echo "‚úÖ All required evidence artifacts present"

      - name: Validate no-minimizing language
        run: |
          echo "=== Checking for Minimizing Language ==="
          
          # Check PR title for banned phrases per POLICY-NO-ONLY-LANGUAGE.md
          BANNED_PATTERNS=("\\bonly\\b" "\\bjust\\b" "\\bsimply\\b" "\\bmerely\\b" "\\btrivial\\b" "\\bminimal\\b" "\\bsmall\\b")
          
          PR_TITLE="${{ github.event.pull_request.title }}"
          
          VIOLATIONS=0
          
          for pattern in "${BANNED_PATTERNS[@]}"; do
            if echo "$PR_TITLE" | grep -qiE "$pattern"; then
              echo "‚ùå Found minimizing language in PR title: $pattern"
              VIOLATIONS=$((VIOLATIONS + 1))
            fi
          done
          
          if [ $VIOLATIONS -gt 0 ]; then
            echo ""
            echo "‚ùå NO-MINIMIZING LANGUAGE CHECK FAILED"
            echo "Violations found: $VIOLATIONS"
            echo "Required by: POLICY-NO-ONLY-LANGUAGE.md"
            exit 1
          fi
          
          echo "‚úÖ No minimizing language detected"

  # Job 2: Governance Alignment
  # Verifies canonical governance alignment state
  governance-alignment:
    name: governance/alignment
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Check governance alignment
        run: |
          echo "=== Checking Governance Alignment ==="
          
          # Check for sync_state.json
          if [ -f ".agent-admin/governance/sync_state.json" ]; then
            echo "‚úÖ Governance sync state found"
            
            # Validate it's valid JSON
            if ! jq empty .agent-admin/governance/sync_state.json 2>/dev/null; then
              echo "‚ùå sync_state.json is not valid JSON"
              exit 1
            fi
            
            # Check for required fields
            VERSION=$(jq -r '.governance_version // "missing"' .agent-admin/governance/sync_state.json)
            if [ "$VERSION" = "missing" ]; then
              echo "‚ö†Ô∏è  Warning: governance_version not specified in sync_state.json"
            else
              echo "‚ÑπÔ∏è  Governance version: $VERSION"
            fi
            
            echo "‚úÖ Governance alignment validated"
          else
            echo "‚ö†Ô∏è  No sync_state.json found - this is acceptable for governance-only PRs"
            echo "‚ÑπÔ∏è  Governance repos maintain alignment via CANON_INVENTORY.json"
          fi

  # Job 3: Stop-and-Fix Enforcement
  # Fails if a stop-and-fix condition is unresolved
  stop-and-fix-enforcement:
    name: stop-and-fix/enforcement
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for stop-and-fix conditions
        run: |
          echo "=== Stop-and-Fix Enforcement ===" 
          
          # Check for stop-and-fix markers in active code (exclude docs, canon, workspace, markdown)
          STOP_MATCHES=$(grep -r "STOP-AND-FIX" . \
            --exclude-dir=".agent-workspace" \
            --exclude-dir=".git" \
            --exclude-dir=".github" \
            --exclude-dir="docs" \
            --exclude-dir="governance" \
            --exclude="*.md" || true)

          if [ -n "$STOP_MATCHES" ]; then
            echo "$STOP_MATCHES"
            echo "‚ùå STOP-AND-FIX marker detected in active code"
            echo ""
            echo "Found unresolved STOP-AND-FIX markers in active code."
            echo "Required action: Resolve the condition and remove the marker"
            echo "Required by: STOP_AND_FIX_DOCTRINE.md"
            exit 1
          fi
          
          # Check for execution halt files (excluding README.md and .archive)
          HALT_FILES=$(find execution-halt -maxdepth 1 -type f ! -name "README.md" ! -name ".gitkeep" 2>/dev/null || echo "")
          if [ -n "$HALT_FILES" ]; then
            echo "‚ùå Execution halt files detected"
            echo ""
            echo "Active halt files:"
            echo "$HALT_FILES" | while read f; do echo "  - $f"; done
            echo ""
            echo "Required action: Resolve halt condition and archive files to .archive/"
            echo "Required by: STOP_AND_FIX_DOCTRINE.md"
            exit 1
          fi
          
          echo "‚úÖ No stop-and-fix conditions detected"

  # Job 4: IAA Assurance Check
  # Requires ASSURANCE-TOKEN for qualifying PRs per INDEPENDENT_ASSURANCE_AGENT_CANON.md
  iaa-assurance-check:
    name: iaa/assurance-check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine if IAA is required
        id: iaa_required
        run: |
          echo "=== IAA Trigger Check ==="

          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD || echo "")
          echo "Changed files:"
          echo "$CHANGED_FILES"

          IAA_REQUIRED=false

          # Label-based triggers
          if [[ "${{ contains(github.event.pull_request.labels.*.name, 'aawp-deliverable') }}" == "true" ]]; then
            echo "üî¥ IAA required: label aawp-deliverable"
            IAA_REQUIRED=true
          fi
          if [[ "${{ contains(github.event.pull_request.labels.*.name, 'mat-deliverable') }}" == "true" ]]; then
            echo "üî¥ IAA required: label mat-deliverable"
            IAA_REQUIRED=true
          fi

          # Path-based triggers
          if echo "$CHANGED_FILES" | grep -qE '^\.github/agents/|^governance/agents/'; then
            echo "üî¥ IAA required: agent contract file changed"
            IAA_REQUIRED=true
          fi
          if echo "$CHANGED_FILES" | grep -qE '^governance/contracts/|.*-agent-contract\.md$'; then
            echo "üî¥ IAA required: agent contract changed"
            IAA_REQUIRED=true
          fi
          if echo "$CHANGED_FILES" | grep -qE '^governance/canon/'; then
            echo "üî¥ IAA required: canon file changed"
            IAA_REQUIRED=true
          fi
          if echo "$CHANGED_FILES" | grep -qE '^governance/quality/agent-integrity/'; then
            echo "üî¥ IAA required: agent-integrity folder changed"
            IAA_REQUIRED=true
          fi
          if echo "$CHANGED_FILES" | grep -qE '^\.github/workflows/merge-gate-interface\.yml$'; then
            echo "üî¥ IAA required: merge gate workflow changed"
            IAA_REQUIRED=true
          fi

          echo "iaa_required=$IAA_REQUIRED" >> $GITHUB_OUTPUT
          if [ "$IAA_REQUIRED" == "true" ]; then
            echo "‚úÖ IAA check is REQUIRED for this PR"
          else
            echo "‚ÑπÔ∏è  IAA check is NOT required for this PR (docs-only / parking-station / admin)"
          fi

      - name: Check for ASSURANCE-TOKEN
        if: steps.iaa_required.outputs.iaa_required == 'true'
        run: |
          echo "=== IAA Assurance Token Check ==="
          echo "Required by: governance/canon/INDEPENDENT_ASSURANCE_AGENT_CANON.md v1.0.0"
          echo ""

          TOKEN_FILES=$(find .agent-admin/assurance/ -maxdepth 1 -name "assurance-token-*.md" 2>/dev/null || true)

          if [ -z "$TOKEN_FILES" ]; then
            echo "‚ùå MERGE BLOCKED: No ASSURANCE-TOKEN found in .agent-admin/assurance/"
            echo ""
            echo "This PR requires Independent Assurance Agent (IAA) sign-off before merge."
            echo ""
            echo "Required action:"
            echo "  1. IAA must review the five-phase delivery proof (Preflight, Governance,"
            echo "     Working, Handover, Assurance Invocation)"
            echo "  2. If all phases pass and agent integrity is verified, IAA issues:"
            echo "     .agent-admin/assurance/assurance-token-<PR#>.md"
            echo "  3. If any phase fails, IAA issues a REJECTION-PACKAGE ‚Äî resolve all"
            echo "     proof gaps before re-requesting assurance"
            echo ""
            echo "See: governance/canon/INDEPENDENT_ASSURANCE_AGENT_CANON.md"

            # Also check for rejection package (informational)
            REJECTION_FILES=$(find .agent-admin/assurance/ -maxdepth 1 -name "rejection-package-*.md" 2>/dev/null || true)
            if [ -n "$REJECTION_FILES" ]; then
              echo ""
              echo "‚ö†Ô∏è  REJECTION-PACKAGE found:"
              echo "$REJECTION_FILES"
              echo "Resolve all items in the rejection package before re-requesting assurance."
            fi

            exit 1
          fi

          echo "‚úÖ ASSURANCE-TOKEN found:"
          echo "$TOKEN_FILES"

          # Verify token is not empty
          for TOKEN_FILE in $TOKEN_FILES; do
            if ! grep -q "ASSURANCE-TOKEN" "$TOKEN_FILE"; then
              echo "‚ùå Token file $TOKEN_FILE does not contain ASSURANCE-TOKEN marker"
              exit 1
            fi
            if ! grep -q "Verdict: MERGE PERMITTED" "$TOKEN_FILE"; then
              echo "‚ùå Token file $TOKEN_FILE does not contain 'Verdict: MERGE PERMITTED'"
              exit 1
            fi
          done

          echo "‚úÖ IAA ASSURANCE-TOKEN validated ‚Äî merge permitted per IAA"

      - name: IAA not required ‚Äî skip
        if: steps.iaa_required.outputs.iaa_required != 'true'
        run: |
          echo "‚ÑπÔ∏è  IAA assurance not required for this PR type"
          echo "‚úÖ iaa/assurance-check: SKIPPED (not applicable)"

  # Job 5: Governance Token Usage Check
  # Validates that write-capable workflow steps use MATURION_BOT_TOKEN, not GITHUB_TOKEN
  governance-token-usage-check:
    name: governance/token-usage-check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for prohibited token usage in write steps
        run: |
          echo "=== Governance Token Usage Check (REQ-TU-001, REQ-TU-002) ==="
          echo "Required by: governance/canon/GOVERNANCE_TOKEN_USAGE_REQUIREMENTS.md"
          echo ""
          bash .github/scripts/validate-token-usage.sh .github/workflows
